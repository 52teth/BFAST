#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <time.h>

#include "../blib/BLibDefinitions.h"
#include "../blib/BError.h"
#include "../blib/AlignEntries.h"
#include "bevalsim.h"

#define Name "bevalsim"
#define COUNT_ROTATE_NUM 100000

/* Parses a balign file resulting from usin reads generated by
 * bgeneratereads to give accuracy statistics for the mapping.
 * */

int main(int argc, char *argv[]) 
{
	char baf[MAX_FILENAME_LENGTH]="\0";
	char readsFile[MAX_FILENAME_LENGTH]="\0";
	int pairedEnd = -1;
	char outputID[MAX_FILENAME_LENGTH]="\0";

	if(argc == 5) {

		/* Get cmd line options */
		strcpy(baf, argv[1]);
		strcpy(readsFile, argv[2]);
		pairedEnd = atoi(argv[3]);
		strcpy(outputID, argv[4]);

		/* Check cmd line options */
		assert(SingleEnd == pairedEnd || PairedEnd == pairedEnd);

		/* Run program */
		Evaluate(baf, 
				readsFile, 
				pairedEnd, 
				outputID);

		/* Terminate */
		fprintf(stderr, "%s", BREAK_LINE);
		fprintf(stderr, "Terminating successfully.\n");
		fprintf(stderr, "%s", BREAK_LINE);
	}
	else {
		fprintf(stderr, "Usage: %s [OPTIONS]\n", Name);
		fprintf(stderr, "\t<bfast aligned file>\n");
		fprintf(stderr, "\t<reads file>\n");
		fprintf(stderr, "\t<paired end 0: false 1: true>\n");
		fprintf(stderr, "\t<output id>\n");
	}
	return 0;
}

void ReadTypeInitialize(ReadType *r)
{
	r->strand=0;
	r->contig=0;
	r->pos=0;
	r->pairedEnd=0;
	r->pairedEndLength=0;
	r->readLength=0;
	r->whichReadVariants=0;
	r->startIndel=0;
	r->indelLength=0;
	r->numSNPs=0;
	r->numErrors=0;
	r->deletionLength=0;
	r->insertionLength=0;
	r->aContig=0;
	r->aPos=0;
	r->aStrand=0;
}

void ReadTypeCopy(ReadType *dest,
		ReadType *src)
{
	/* Only copy meta data */ 
	dest->strand=src->strand;
	dest->contig=src->contig;
	dest->pos=src->pos;
	dest->pairedEnd=src->pairedEnd;
	dest->pairedEndLength=src->pairedEndLength;
	dest->readLength=src->readLength;
	dest->whichReadVariants=src->whichReadVariants;
	dest->startIndel=src->startIndel;
	dest->indelLength=src->indelLength;
	dest->numSNPs=src->numSNPs;
	dest->numErrors=src->numErrors;
	dest->deletionLength=src->deletionLength;
	dest->insertionLength=src->insertionLength;
}

void ReadTypePrint(ReadType *r, FILE *fp)
{
	fprintf(fp, "strand=%c\n", r->strand);
	fprintf(fp, "contig=%d\n", r->contig);
	fprintf(fp, "pos=%d\n", r->pos);
	fprintf(fp, "pairedEnd=%d\n", r->pairedEnd);
	fprintf(fp, "pairedEndLength=%d\n", r->pairedEndLength);
	fprintf(fp, "readLength=%d\n", r->readLength);
	fprintf(fp, "whichReadVariants=%d\n", r->whichReadVariants);
	fprintf(fp, "startIndel=%d\n", r->startIndel);
	fprintf(fp, "indelLength=%d\n", r->indelLength);
	fprintf(fp, "numSNPs=%d\n", r->numSNPs);
	fprintf(fp, "numErrors=%d\n", r->numErrors);
	fprintf(fp, "deletionLength=%d\n", r->deletionLength);
	fprintf(fp, "insertionLength=%d\n", r->insertionLength);
}

int ReadTypeCompare(ReadType *a,
		ReadType *b)
{
	/* Only compare meta data */ 
	/* Nice use of if, else if, and else statements */
	if(a->pairedEnd != b->pairedEnd) {
		return (a->pairedEnd < b->pairedEnd)?-1:1;
	}
	else if(a->pairedEndLength != b->pairedEndLength) {
		return (a->pairedEndLength < b->pairedEndLength)?-1:1;
	}
	else if(a->readLength != b->readLength) {
		return (a->readLength < b->readLength)?-1:1;
	}
	else if(a->whichReadVariants != b->whichReadVariants) {
		return (a->whichReadVariants < b->whichReadVariants)?-1:1;
	}
	else if(a->indelLength != b->indelLength) {
		return (a->indelLength < b->indelLength)?-1:1;
	}
	else if(a->numSNPs != b->numSNPs) {
		return (a->numSNPs < b->numSNPs)?-1:1;
	}
	else if(a->numErrors != b->numErrors) {
		return (a->numErrors < b->numErrors)?-1:1;
	}
	else if(a->deletionLength != b->deletionLength) {
		return (a->deletionLength < b->deletionLength)?-1:1;
	}
	else if(a->insertionLength != b->insertionLength) {
		return (a->insertionLength < b->insertionLength)?-1:1;
	}
	else {
		return 0;
	}
}

int ReadTypeReadFromBAF(ReadType *r, 
		int pairedEnd,
		FILE *fp)
{
	char *FnName = "ReadTypeReadFromBAF";
	AlignEntries a;

	/* Initialize */
	AlignEntriesInitialize(&a);

	/* Read in align entries */
	if(EOF==AlignEntriesRead(&a, fp, PairedEndDoesNotMatter, SpaceDoesNotMatter, BALIGN_DEFAULT_OUTPUT)) {
		return EOF;
	}
	/* There should be only one */
	if(a.numEntriesOne > 1 ||
			(a.pairedEnd == 1 && a.numEntriesOne > 1)) {
		PrintError(FnName,
				NULL,
				"There was more than one alignment for a given read",
				Exit,
				OutOfRange);
	}

	r->aContig = a.entriesOne->contig;
	r->aPos = a.entriesOne->position;
	r->aStrand = a.entriesOne->strand;

	assert(a.pairedEnd == pairedEnd);

	/* Convert into read type */
	ReadTypeParseReadName(r, a.pairedEnd, a.readName);

	/* Delete align entries */
	AlignEntriesFree(&a);

	return 1;
}

void ReadTypeParseReadName(ReadType *r, int pairedEnd, char *readName)
{
	char *FnName="ReadTypeParseR1R2";
	char r1[SEQUENCE_LENGTH]="\0";
	char r2[SEQUENCE_LENGTH]="\0";
	char tempString[SEQUENCE_LENGTH]="\0";
	int i, j;
	char tempChar;
	int state;

	if(EOF == sscanf(readName, 
				">strand=%c_contig=%d_pos=%d_pe=%d_pel=%d_rl=%d_wrv=%d_si=%d_il=%d_r1=%s",
				&r->strand,
				&r->contig,
				&r->pos,
				&r->pairedEnd,
				&r->pairedEndLength,
				&r->readLength,
				&r->whichReadVariants,
				&r->startIndel,
				&r->indelLength,
				tempString)) {
		PrintError(FnName,
				readName,
				"Could not parse read name (0)",
				Exit,
				OutOfRange);
	}
	if(SingleEnd == pairedEnd) {
		strcpy(r1, tempString);
	}
	else {
		/* Parse tempString */
		i=j=0;
		state = 0;
		while(EOF != sscanf(tempString+i, "%c", &tempChar)) {
			switch(tempChar) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					/*
					fprintf(stderr, "0-9=%c\n", tempChar);
					*/
					if(0 == state) {
						r1[j] = tempChar;
						j++;
					}
					else if(2 == state) {
						r2[j] = tempChar;
						j++;
					}
					break;
				case '=':
					/*
					fprintf(stderr, "==%c\n", tempChar);
					*/
					state = 2;
					r1[j] = '\0';
					j=0;
					break;
				default:
					/*
					fprintf(stderr, "tempChar=%c\n", tempChar);
					*/
					assert(0 <= state && state <= 1);
					state = 1;
					break;
			}
			i++;
		}
		r2[j] = '\0';
		/*
		fprintf(stderr, "j=%d\n", j);
		fprintf(stderr, "r->readLength=%d\nr1=%s\nr1(length)=%d\n",
				r->readLength,
				r1,
				(int)strlen(r1));
		fprintf(stderr, "r->readLength=%d\nr2=%s\nr2(length)=%d\n",
				r->readLength,
				r2,
				(int)strlen(r2));
				*/
		assert(state == 2);
	}

	assert(r->pairedEnd == pairedEnd);

	/* Parse r1 and r2 */
	assert(r->readLength == (int)strlen(r1));
	assert(r->pairedEnd == 0 || r->readLength == (int)strlen(r2));
	r->numSNPs = 0;
	r->numErrors = 0;
	r->deletionLength = 0;
	r->insertionLength = 0;
	for(i=0;i<r->readLength;i++) {
		switch(r1[i]) {
			case '0':
				/* Default */
				break;
			case '1':
				/* Insertion */
				r->insertionLength++;
				break;
			case '2':
				/* SNP */
				r->numSNPs++;
				break;
			case '3':
				/* Error */
				r->numErrors++;
				break;
			case '4':
				/* InsertionAndSNP */
				r->insertionLength++;
				r->numSNPs++;
				break;
			case '5':
				/* InsertionAndError */
				r->insertionLength++;
				r->numErrors++;
				break;
			case '6':
				/* SNPAndError */
				r->numSNPs++;
				r->numErrors++;
				break;
			case '7':
				/* InsertionSNPAndError */
				r->insertionLength++;
				r->numSNPs++;
				r->numErrors++;
				break;
			default:
				PrintError(FnName,
						"r1[i]",
						"Could not understand type",
						Exit,
						OutOfRange);
		}
		if(r->pairedEnd == 1) {
			switch(r2[i]) {
				case '0':
					/* Default */
					break;
				case '1':
					/* Insertion */
					r->insertionLength++;
					break;
				case '2':
					/* SNP */
					r->numSNPs++;
					break;
				case '3':
					/* Error */
					r->numErrors++;
					break;
				case '4':
					/* InsertionAndSNP */
					r->insertionLength++;
					r->numSNPs++;
					break;
				case '5':
					/* InsertionAndError */
					r->insertionLength++;
					r->numErrors++;
					break;
				case '6':
					/* SNPAndError */
					r->numSNPs++;
					r->numErrors++;
					break;
				case '7':
					/* InsertionSNPAndError */
					r->insertionLength++;
					r->numSNPs++;
					r->numErrors++;
					break;
				default:
					PrintError(FnName,
							"r2[i]",
							"Could not understand type",
							Exit,
							OutOfRange);
			}
		}
	}
	if(r->startIndel >= 0 && r->insertionLength == 0) {
		r->deletionLength = r->indelLength;
	}
}

void StatInitialize(Stat *s, 
		ReadType *r)
{
	s->numCorrectlyAligned[0]=0;
	s->numCorrectlyAligned[1]=0;
	s->numCorrectlyAligned[2]=0;
	s->numCorrectlyAligned[3]=0;
	s->numCorrectlyAligned[4]=0;
	ReadTypeCopy(&s->r, r);
	s->numAligned=0;
	s->numReads=0;
}

void StatPrint(Stat *s, FILE *fp)
{
	fprintf(fp, "%10d %10d %10d %10d %10d %10d %10d ",
			s->numReads,
			s->numAligned,
			s->numCorrectlyAligned[0],
			s->numCorrectlyAligned[1],
			s->numCorrectlyAligned[2],
			s->numCorrectlyAligned[3],
			s->numCorrectlyAligned[4]);
	fprintf(fp, "%1d %6d %6d %6d %3d %3d %3d %3d\n",
			s->r.pairedEnd,
			s->r.pairedEndLength,
			s->r.readLength,
			s->r.indelLength,
			s->r.numSNPs,
			s->r.numErrors,
			s->r.deletionLength,
			s->r.insertionLength);
}

void StatAdd(Stat *s, ReadType *r, int readType)
{
	int diff;

	assert(OriginalRead == readType || AlignedRead == readType);

	if(OriginalRead == readType) {
		s->numReads++;
	}
	else {
		if(r->strand == r->aStrand &&
				r->contig == r->aContig) {
			diff = (r->pos > r->aPos)?(r->pos - r->aPos):(r->aPos - r->pos);

			/* Update */
			if(diff <= 10000) {
				s->numCorrectlyAligned[4]++;
				if(diff <= 1000) {
					s->numCorrectlyAligned[3]++;
					if(diff <= 100) {
						s->numCorrectlyAligned[2]++;
						if(diff <= 10) {
							s->numCorrectlyAligned[1]++;
							if(diff <= 0) {
								s->numCorrectlyAligned[0]++;
							}
						}
					}
				}
			}
		}
		s->numAligned++;
		assert(s->numAligned <= s->numReads);
	}
}

void StatsInitialize(Stats *s) 
{
	s->stats=NULL;
	s->numStats=0;
}

void StatsPrintHeader(FILE *fp)
{
	fprintf(fp, "# COL | Description\n");
	fprintf(fp, "# 0   | number of reads\n");
	fprintf(fp, "# 1   | number of reads aligned\n");
	fprintf(fp, "# 2   | number of correctly aligned within 0 bases\n");
	fprintf(fp, "# 3   | number of correctly aligned within 10 bases\n");
	fprintf(fp, "# 4   | number of correctly aligned within 100 bases\n");
	fprintf(fp, "# 5   | number of correctly aligned within 1000 bases\n");
	fprintf(fp, "# 6   | number of correctly aligned within 10000 bases\n");
	fprintf(fp, "# 7   | paired end\n");
	fprintf(fp, "# 8   | paired end length\n");
	fprintf(fp, "# 9   | read length\n");
	fprintf(fp, "# 10  | indel length\n");
	fprintf(fp, "# 11  | number of snps\n");
	fprintf(fp, "# 12  | number of errors\n");
	fprintf(fp, "# 13  | deletion length\n");
	fprintf(fp, "# 14  | insertion length\n");
}

void StatsPrint(Stats *s, FILE *fp)
{
	int32_t i;
	StatsPrintHeader(fp);
	for(i=0;i<s->numStats;i++) {
		StatPrint(&s->stats[i], fp);
	}
}

void StatsAdd(Stats *s, ReadType *r, int readType)
{
	int32_t i;
	char *FnName="StatsAdd";

	assert(OriginalRead == readType || AlignedRead == readType);

	/* Check if it fits somewhere */
	for(i=0;i<s->numStats;i++) {
		if(ReadTypeCompare(r, &s->stats[i].r)==0) {
			/*
			   fprintf(stderr, "%s", BREAK_LINE);
			   ReadTypePrint(r, stderr);
			   ReadTypePrint(&s->stats[i].r, stderr);
			   fprintf(stderr, "HERE fits exiting!\n");
			   fprintf(stderr, "%s", BREAK_LINE);
			   exit(1);
			   */
			/* Add to current */
			StatAdd(&s->stats[i], r, readType);
			return; /* Get out of here */
		}
	}
	if(AlignedRead == readType) {
		ReadTypePrint(r, stderr);
		PrintError(FnName,
				NULL,
				"Read type was not found in the original reads file",
				Exit,
				OutOfRange);
	}
	else {
		/* Otherwise start a new start entry */
		s->numStats++;
		s->stats = realloc(s->stats, sizeof(Stat)*s->numStats);
		if(NULL==s->stats) {
			PrintError(FnName,
					"s->stats",
					"Could not allocate memory",
					Exit,
					MallocMemory);
		}
		/* Initialize */
		StatInitialize(&s->stats[s->numStats-1], r);
		/* Add */
		StatAdd(&s->stats[s->numStats-1], r, readType);
	}
}

void StatsDelete(Stats *s)
{
	free(s->stats);
	s->stats=NULL;
	s->numStats=0;
}

void Evaluate(char *baf,
		char *readsFile,
		int pairedEnd,
		char *outputID)
{
	char *FnName="Evaluate";
	FILE *fpIn;
	FILE *fpOut;
	ReadType r;
	Stats s;
	int32_t count;
	char outputFileName[MAX_FILENAME_LENGTH]="\0";

	StatsInitialize(&s);

	/* Get the number of reads for each class */
	ReadInReads(readsFile, pairedEnd, &s);

	ReadTypeInitialize(&r);

	/* Open the baf file */
	if(!(fpIn=fopen(baf, "rb"))) {
		PrintError(FnName,
				baf,
				"Could not open file for reading",
				Exit,
				OpenFileError);
	}

	count = 0;
	fprintf(stderr, "Reading in aligned reads from %s.\nCurrently on:\n%d", baf, 0);
	while(EOF != ReadTypeReadFromBAF(&r, pairedEnd, fpIn)) {
		count++;
		if(count % COUNT_ROTATE_NUM == 0) {
			fprintf(stderr, "\r%d", 
					count);
		}

		/* Process the read */
		StatsAdd(&s, &r, AlignedRead);

		/* Reinitialize */
		ReadTypeInitialize(&r);
	}
	fprintf(stderr, "\r%d\n", count);

	/* Create output file name */
	sprintf(outputFileName, "%s.evalsim.%s.txt",
			PROGRAM_NAME,
			outputID);
	/* Open the output file */
	fprintf(stderr, "%s", BREAK_LINE);
	fprintf(stderr, "Outputting to %s.\n",
			outputFileName);
	if(!(fpOut=fopen(outputFileName, "wb"))) {
		PrintError(FnName,
				outputFileName,
				"Could not open file for writing",
				Exit,
				WriteFileError);
	}

	/* Print Stats */
	StatsPrint(&s, fpOut);
	fprintf(stderr, "%s", BREAK_LINE);

	/* Delete Stats */
	StatsDelete(&s);

	/* Close the files */
	fclose(fpIn);
	fclose(fpOut);
}

void ReadInReads(char *readsFile, int pairedEnd, Stats *s)
{
	char *FnName="ReadInReads";
	FILE *fpIn=NULL;
	int count=0;
	ReadType r;
	char readName[SEQUENCE_NAME_LENGTH]="\0";
	char r1[SEQUENCE_LENGTH]="\0";
	char r2[SEQUENCE_LENGTH]="\0";

	assert(PairedEnd == pairedEnd || SingleEnd == pairedEnd);

	/* Open the reads file */
	if(!(fpIn=fopen(readsFile, "rb"))) {
		PrintError(FnName,
				readsFile,
				"Could not open file for reading",
				Exit,
				OpenFileError);
	}

	fprintf(stderr, "Reading in original reads from %s.\nCurrently on:\n%d", readsFile, 0);
	count = 0;
	/* Read in read name and read(s) */
	while(EOF != fscanf(fpIn, "%s", readName) &&
			EOF != fscanf(fpIn, "%s", r1) &&
			(SingleEnd == pairedEnd || EOF != fscanf(fpIn, "%s", r2))) {
		ReadTypeInitialize(&r);

		count++;
		if(count % COUNT_ROTATE_NUM == 0) {
			fprintf(stderr, "\r%d[%d]", 
					count,
					s->numStats
				   );
		}
		ReadTypeParseReadName(&r, pairedEnd, readName);

		/* Add to Stats */
		StatsAdd(s, &r, OriginalRead);

		r1[0]='\0';
		r2[0]='\0';
	}
	fprintf(stderr, "\r%d[%d]\n", 
			count,
			s->numStats
		   );

	/* Close the files */
	fclose(fpIn);
}
